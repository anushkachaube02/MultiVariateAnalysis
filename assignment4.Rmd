---
title: "Factor_Analysis"
output: html_document
date: "03/18/23"
author: Anushka Chaube
---
```{r}
# Factor Analysis
library(psych)

winequality <- read.csv("/Users/anushkachaube/Library/Containers/com.microsoft.Excel/Data/Downloads/winequalityN.csv")

attach(winequality)
winequality[1]
wq.pc <- principal(winequality[-1], nfactors=4, rotate="varimax")
wq.pc
round(wq.pc$values, 3)
wq.pc$loadings
# Loadings with more digits
for (i in c(1,3,2,4)) { print(wq.pc$loadings[[1,i]])}
# Communalities
wq.pc$communality
# Rotated factor scores, Notice the columns ordering: RC1, RC3, RC2 and RC4
wq.pc$scores
# Play with FA utilities
fa.parallel(winequality[-1]) # See factor recommendation
fa.plot(wq.pc) # See Correlations within Factors
fa.diagram(wq.pc) # Visualize the relationship
vss(winequality[-1]) # See Factor recommendations for a simple structure




# Computing Correlation Matrix
corrm.wq <- cor(winequality[-1])
corrm.wq
plot(corrm.wq)
winequality_pca <- prcomp(winequality[-1], scale=TRUE)
summary(winequality_pca)
plot(winequality_pca)
# A table containing eigenvalues and %'s accounted, follows. Eigenvalues are the sdev^2
(eigen_wine <- round(winequality_pca$sdev^2,3))
round(wq.pc$values, 3)
names(eigen_wine) <- paste("PC",1:8,sep="")
eigen_wine
sumlambdas <- sum(eigen_wine)
sumlambdas
propvar <- round(eigen_wine/sumlambdas,2)
propvar
cumvar_wine <- cumsum(propvar)
cumvar_wine
matlambdas <- rbind(eigen_wine,propvar,cumvar_wine)
matlambdas
rownames(matlambdas) <- c("Eigenvalues","Prop. variance","Cum. prop. variance")
rownames(matlambdas)
eigvec.wq <- winequality_pca$rotation
print(winequality_pca)
# Taking the first four PCs to generate linear combinations for all the variables with four factors
pcafactors.wq <- eigvec.wq[,1:4]
pcafactors.wq
# Multiplying each column of the eigenvectorâ€™s matrix by the square-root of the corresponding eigenvalue in order to get the factor loadings
unrot.fact.wq <- sweep(pcafactors.wq,MARGIN=2,winequality_pca$sdev[1:4],`*`)
unrot.fact.wq
# Computing communalities
communalities.wq <- rowSums(unrot.fact.wq^2)
communalities.wq
# Performing the varimax rotation. The default in the varimax function is norm=TRUE thus, Kaiser normalization is carried out
rot.fact.wq <- varimax(unrot.fact.wq)
#View(unrot.fact.emp)
rot.fact.wq
# The print method of varimax omits loadings less than abs(0.1). In order to display all the loadings, it is necessary to ask explicitly the contents of the object $loadings
fact.load.wq <- rot.fact.wq$loadings[1:8,1:4]
fact.load.wq
# Computing the rotated factor scores for the 30 European Countries. Notice that signs are reversed for factors F2 (PC2), F3 (PC3) and F4 (PC4)
scale.wq <- scale(winequality[-1])
scale.wq
as.matrix(scale.wq)%*%fact.load.wq%*%solve(t(fact.load.wq)%*%fact.load.wq)

```

